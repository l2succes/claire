generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_DATABASE_URL")
}

model User {
  id                String             @id @default(cuid())
  email             String             @unique
  name              String?
  avatarUrl         String?
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  
  whatsappSessions  WhatsAppSession[]
  messages          Message[]
  promises          Promise[]
  contacts          Contact[]
  memories          Memory[]
  autoReplyRules    AutoReplyRule[]
  
  @@map("users")
}

model WhatsAppSession {
  id                String             @id @default(cuid())
  userId            String
  phoneNumber       String
  sessionData       Json
  isActive          Boolean            @default(true)
  lastConnected     DateTime           @default(now())
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  
  user              User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([userId, phoneNumber])
  @@map("whatsapp_sessions")
}

model Contact {
  id                String             @id @default(cuid())
  userId            String
  whatsappId        String
  phoneNumber       String?
  name              String?
  avatarUrl         String?
  relationship      String?            // e.g., "friend", "family", "colleague", "boss"
  inferredIdentity  Json?              // AI-inferred identity information
  isVerified        Boolean            @default(false)
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  
  user              User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  sentMessages      Message[]          @relation("SentMessages")
  receivedMessages  Message[]          @relation("ReceivedMessages")
  promises          Promise[]
  
  @@unique([userId, whatsappId])
  @@index([userId])
  @@map("contacts")
}

model Message {
  id                String             @id @default(cuid())
  userId            String
  whatsappMessageId String
  senderId          String?
  receiverId        String?
  groupId           String?
  content           String
  mediaUrl          String?
  mediaType         String?            // "image", "video", "document", "audio"
  timestamp         DateTime
  isFromMe          Boolean
  isRead            Boolean            @default(false)
  isReplied         Boolean            @default(false)
  suggestedReply    String?
  actualReply       String?
  replyStatus       ReplyStatus        @default(PENDING)
  metadata          Json?
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  
  user              User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  sender            Contact?           @relation("SentMessages", fields: [senderId], references: [id])
  receiver          Contact?           @relation("ReceivedMessages", fields: [receiverId], references: [id])
  group             Group?             @relation(fields: [groupId], references: [id])
  promises          Promise[]
  
  @@unique([userId, whatsappMessageId])
  @@index([userId, timestamp])
  @@index([userId, isReplied])
  @@map("messages")
}

model Group {
  id                String             @id @default(cuid())
  whatsappId        String             @unique
  name              String
  description       String?
  avatarUrl         String?
  participantCount  Int                @default(0)
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  
  messages          Message[]
  
  @@map("groups")
}

model Promise {
  id                String             @id @default(cuid())
  userId            String
  messageId         String?
  contactId         String?
  content           String
  extractedText     String             // The actual promise text extracted
  dueDate           DateTime?
  priority          Priority           @default(MEDIUM)
  status            PromiseStatus      @default(PENDING)
  category          String?            // e.g., "meeting", "delivery", "payment"
  reminderSent      Boolean            @default(false)
  reminderDate      DateTime?
  completedAt       DateTime?
  notes             String?
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  
  user              User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  message           Message?           @relation(fields: [messageId], references: [id])
  contact           Contact?           @relation(fields: [contactId], references: [id])
  
  @@index([userId, status])
  @@index([userId, dueDate])
  @@map("promises")
}

model Memory {
  id                String             @id @default(cuid())
  userId            String
  key               String             // e.g., "tone_preference", "common_phrases"
  value             Json
  category          String             // e.g., "preferences", "relationships", "context"
  expiresAt         DateTime?
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  
  user              User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([userId, key])
  @@index([userId, category])
  @@map("memories")
}

model AutoReplyRule {
  id                String             @id @default(cuid())
  userId            String
  name              String
  trigger           Json               // Conditions for triggering
  replyTemplate     String
  isActive          Boolean            @default(true)
  priority          Int                @default(0)
  maxUsesPerDay     Int?
  usedToday         Int                @default(0)
  lastUsedAt        DateTime?
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  
  user              User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId, isActive])
  @@map("auto_reply_rules")
}

enum ReplyStatus {
  PENDING
  SUGGESTED
  APPROVED
  SENT
  FAILED
}

enum PromiseStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  CANCELLED
  OVERDUE
}

enum Priority {
  LOW
  MEDIUM
  HIGH
  URGENT
}